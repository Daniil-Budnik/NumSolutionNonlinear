# Метод Ньютона (касательных)
# Функция, его производная, начало и конец, точность, вернуть кол-во шагов
def Tangent_Method(F, dF, A = 0, B = 1, E = 0.01, Step = False):
    X, I = ((A + B) / 2), 0                         # Назодим первую X
    while (abs(F(X)) > E):                          # Проверка X при определённой точности
        I += 1                                      # Счётчик
        X = X - (F(X) / dF(X))                      # Находим след Xi
    if(Step): return [X, I]                         # Возвращаем значение корня и кол-во шагов
    else: return X                                  # Возвращаем значение корня

# Метод половинного деления
# Функция, начало, конец, точность, увиличение мощности, смещение, вернуть кол-во шагов
def Half_Division(F, A = 0, B = 1, E = 0.01, K1 = 1, K2 = 0, Step = False):
    S , I = abs(A - B), 0                           # Узнаём длину, счётчик в нулевой момент времени
    while ( S > E ):                                # Цикл нахождения корня
        I += 1                                      # Счётчик
        C = (A + B) / 2                             # Находим С (середину)
        # Проверка, откинуть левую или правую часть в случае f(x1) * f(x2) < 0
        if( ( ( F(A) * K1 ) + K2 ) * ( ( F(C) * K1 ) + K2 ) > 0): A = C
        else: B = C
        S = abs(A - B)                              # Длина отрезка
    if(Step): return [( (A + B) / 2 ), I]           # Возвращаем значение корня и кол-во шагов
    else: return ( (A + B) / 2 )                    # Возвращаем значение корня
    
 # Определитель матрицы с помощью миноров
 def Determinant(M):
    # Порядок матрицы
    L = len(M)
    
    # Проверка квадратной матрицы и правильности данных
    if(L > 1):                                      # Если матрица размерности больше чем 1
        for i in range(L):                          # Перебираем все строки
            if(len(M[i]) != L):                     # Если в строки значений меньше или больше чем кол-во строк
                return 0                            # Значит матрица не квадратная или заполнена неправильно
    
    # Случай с одномерной матрицей
    if(L == 1): return M

    # Случай с двухмерной матрицей
    elif(L == 2): return M[0][0] * M[1][1] - M[1][0] * M[0][1]

    # Случай с n-мерной матрицей
    else:
        Op = 0                                      # Резервируем переменную для определителя
        for K in range(L):                          # Считае миноры
            Mi = []                                 # Резервируем переменную для матрицы
            for Y in range(1,L):                    # Считаем определители без 1-ой строки
                Mi.append([])                       # Создаём i-ую строку
                for X in range(L):                  # Считаем определитель без j-ого столбца
                    if(X != K):                     # Проверка столбца
                        Mi[Y-1].append(M[Y][X])     # Заполняем матрицу
                    
            # Считаем определитель без i строки и j-ого столбца
            # и умножаем на алгебраическое дополнение и порядок
            Op += M[0][K] * Determinant(Mi) * ((-1) ** (K+2))

        # Возвращаем результат  
        return Op
